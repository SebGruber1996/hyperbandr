% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Bracket.R
\docType{data}
\name{bracket}
\alias{bracket}
\title{R6 class to create single bracket objects}
\format{\code{\link{R6Class}} object}
\usage{
bracket
}
\value{
Bracket object
}
\description{
An \code{\link[R6]{R6Class}} that consits of multiple algorithm objects
}
\section{Fields}{

\describe{
\item{\code{max.perf}}{[\code{logical(1)}]\cr
\code{TRUE} if \code{performance.fun} should be maximized (e.g. accuracy of a neural net),
\code{FALSE} if it should be mimized (e.g. misclassifaction error). Default is \code{TRUE}.}

\item{\code{max.resources}}{[\code{integer(1)}]\cr
The maximum amount of resources (e.g. iterations) that can be allocated to a single configuration.}

\item{\code{prop.discar}}{[\code{integer(1)}]\cr
Proportion of configurations to be discarded in each round of successive halving.}

\item{\code{s}}{[\code{integer(1)}]\cr
The s'th bracket object to create. Note that s is in \cr
\code{(0,...,floor(log(max.resources, base = prop.discard)))}.}

\item{\code{B}}{[\code{integer(1)}]\cr
The total budget for the bracket. Note that B is given by  \cr
\code{(max(s) + 1)*max.resources}.}

\item{\code{id}}{\code{character(1)}]\cr
Name used for \code{\link{algorithm}} objects.}

\item{\code{par.set}}{[\code{\link[ParamHelpers]{ParamSet}}]\cr
Parameter set to tune over.}

\item{\code{sample.fun}}{[\code{function}]\cr
The function to sample from par.set. Takes \dQuote{par.set} and number of configurations to sample \dQuote{n} as arguments.
If no set, random sampling with \code{\link[ParamHelpers]{sampleValues}} is used.}

\item{\code{train.fun}}{[\code{function}]\cr
The function to carry out training. Takes the result of \code{init.fun} as first argument, \dQuote{budget} to specify how many resources should be added and \code{problem}.
Should return an object that can be passed to \code{train.fun} again.}

\item{\code{performance.fun}}{[\code{function}]\cr
The function to measure the performance.
Takes argumennts \dQuote{model} (result of \code{train.fun}) and \code{problem}.}
}}

\section{Methods}{

\code{$run()} computes the whole bracket \cr
\code{$step()} computes one iteration of successive halving \cr
\code{$getTopKModels(k)} displays the best k models \cr
\code{$filterTopKModels(k)} filters the best k models and deletes the remaining models from the bracket object \cr
\code{$getPerformances()} computes the performance of all remaining models \cr
}

\examples{

# we need some packages
library("ggplot2")
library("smoof")
library("data.table")

# we choose the 2 dimensional branin function
braninProb = makeBraninFunction()

# the branin function has 3 global minima
opt = data.table(x1 = getGlobalOptimum(braninProb)$param$x1,
  x2 = getGlobalOptimum(braninProb)$param$x2)
param.set = getParamSet(braninProb)


#######################################
## define functions to use hyperband ##
#######################################

# config space
configSpace = makeParamSet(
    makeNumericParam(id = "x1", lower = -5, upper = 10.1))

# sample fun
sample.fun = function(par.set, n.configs, ...) {
  sampleValues(par = par.set, n = n.configs)
}

# init fun
init.fun = function(r, config, problem) {
  x1 = unname(unlist(config))
  x2 = runif(1, 0, 15)
  mod = c(x1, x2)
  return(mod)
}

# train fun
train.fun = function(mod, budget, problem) {
  for(i in seq_len(budget)) {
    mod.new = c(mod[[1]], mod[[2]] + rnorm(1, sd = 3))
    if(performance.fun(mod.new) < performance.fun(mod))
      mod = mod.new
  }
  return(mod)
}

# performance fun
performance.fun = function(model, problem) {
  braninProb(c(model[[1]], model[[2]]))
}
###### make branin bracket object #####
brack = bracket$new(
  problem = braninProb,
  max.perf = FALSE,
  max.resources = 81,
  prop.discard = 3,
  s = 4,
  B = (4 + 1)*81,
  id = "branin",
  par.set = configSpace,
  sample.fun = sample.fun,
  init.fun = init.fun,
  train.fun = train.fun,
  performance.fun = performance.fun)

# the data matrix shows us the hyperparameters, the current budget and the performance
brack$bracket.storage$data.matrix
# run the bracket
brack$run()
# inspect the data matrix again
brack$bracket.storage$data.matrix
# visualize the the bracket
# access the performance of the best model
brack$getPerformances()
}
\keyword{datasets}
