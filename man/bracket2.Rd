% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Bracket2.R
\docType{data}
\name{bracket2}
\alias{bracket2}
\title{R6 class to create single bracket objects}
\format{\code{\link{R6Class}} object}
\usage{
bracket2
}
\value{
Bracket object
}
\description{
An \code{\link[R6]{R6Class}} that consits of multiple algorithm objects
}
\section{Fields}{

\describe{
\item{\code{max.perf}}{[\code{logical()}]\cr
TRUE if to maximize the performance (e.g. accuracy of a neural net), 
FALSE if to minimize the performance (e.g. find the minimum of the branin function).}

\item{\code{max.ressources}}{[\code{integer()}]\cr
The maximum amount of resource that canbe allocated to a single configuration}

\item{\code{prop.discard}}{[\code{integer()}]\cr
An input that controls the proportion of configurations discarded in each round of successive halving}

\item{\code{s}}{[\code{integer()}]\cr
The s'th bracket object to create. Note that s is in \cr
\code{(0,...,floor(log(max.ressources, base = prop.discard)))}}

\item{\code{B}}{[\code{integer()}]\cr
The total budget for the bracket. Note that B is given by  \cr
\code{(max(s) + 1)*max.ressources}}

\item{\code{id}}{[\code{string}]\cr
An id for each Algorithm object in the bracket object}

\item{\code{par.set}}{\cr
The parameter set to sample from}

\item{\code{sample.fun}}{\cr
The function to sample from par.set}

\item{\code{train.fun}}{\cr
The function to carry out training}

\item{\code{performance.fun}}{The function to measure the performance}
}}
\section{Methods}{

\code{$run()} computes the whole bracket \cr
\code{$step()} computes one iteration of successive halving \cr
\code{$getTopKModels(k)} displays the best k models \cr
\code{$filterTopKModels(k)} filters the best k models and deletes the remaining models from the bracket object \cr
\code{$getPerformances()} computes the performance of all remaining models \cr
}
\examples{
# simple example for the branin function (minimization problem)
library("smoof")
problem = makeBraninFunction()

# configuration space:
configSpace = makeParamSet(
  makeNumericParam(id = "x1", lower = -5, upper = 10.1))
  
# sampling function:
sample.fun = function(par.set, n.configs) {
 sampleValues(par = par.set, n = n.configs)
}
 
# model initialization function:
init.fun = function(r, config) {
  x1 = unname(unlist(config))
  x2 = runif(1, 0, 15)
  mod = c(x1, x2)
  return(mod)
}

# training function:
train.fun = function(mod, budget) {
  for(i in seq_len(budget)) {
    mod.new = c(mod[[1]], mod[[2]] + rnorm(1, sd = 3))
    if(performance.fun(mod.new) < performance.fun(mod))
      mod = mod.new
  }
  return(mod)
}

# performance function:
performance.fun = function(model) {
  problem(c(model[[1]], model[[2]]))
}

# create bracket s = 4 with hyperbands recommended parameters
brack = bracket$new(
  max.perf = FALSE,
  max.ressources = 81,
  prop.discard = 3, 
  s = 4, 
  B = (4 + 1)*81,
  id = "branin",
  par.set = configSpace,
  sample.fun = sample.fun,
  train.fun = train.fun,
  performance.fun = performance.fun
)

# carry out successive halving:
brack$run()

# get the performance of the remaining (best) model
brack$getPerformances()

# visualize the results (red: global minima, blue: result of the bracket)
opt = data.table(x1 = getGlobalOptimum(problem)$param$x1, x2 = getGlobalOptimum(problem)$param$x2)
(vis = autoplot(problem) 
  + geom_point(data = opt, aes(x = x1, y = x2), 
               shape = 4, colour = "red", size = 5) 
  + geom_point(aes(x = brack$models[[1]]$model[[1]], y = brack$models[[1]]$model[[2]]), 
               shape = 4, colour = "blue", size = 5))
}
\keyword{datasets}

